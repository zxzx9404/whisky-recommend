## 전반

- AUTO_INCREMENT는 코멘트에 달기 → 원래 그거 써있던 곳은 INT 같은 타입이 있어야 함
- 큰 숫자가 필요하지 않다면, INT 대신 TINY INT 사용
- clob은 잘 안씀 → TEXT로
- RDB는 빠르지 않다. 대신 관계를 맺을 수 있는 것
    - 편의성을 위해 성능을 약간 포기
    - 너무 DB의 양이 많아져서 NoSQL 등을 이용할 경우 속도는 더 빨리질 수 있지만 뭔가 추가적인 작업이 들어가야함
- 사용자의 데이터 관리
    - 사용자가 데이터를 삭제한 경우, 실제 DB에서는 지우지 않는다.
    - 유저가 생성한 데이터는 소중하기 때문
    - is_deleted, is_active 등의 변수를 만들어 노출 여부를 조절하는 방식을 쓴다
- ERD Cloud → 전체적으로 코멘트, 물리적(한글명) 등등 다 만들자

### 이미지

- 위스키, 멤버는 이미지 1개라서 필드값으로 추가하고, 리뷰는 5개라서 테이블로 뺐는데, 어떻게 관리하는게 나을까?
    - 이미지만을 관리하는 테이블을 1개 만들어서, 어떤 이미지든 다 거기서 찾아와라
    - 해당 방식을 차용할 경우, 리뷰 이미지는 순서까지 저장되어있어야 함
- 유저가 이미지를 삭제했을 때, 이미지를 삭제하고 새로 생성해도 되고, 아니면 활성화 여부를 만들어서, 기존 사진은 비활성화 처리하고 활성화된 사진을 보여주면 됨
- 보통 이미지는 url(외부)으로 접근하지 않고, 물리적 공간에서 찾아와서 binary형태로 전달함
    - 보안상의 문제 때문
    - meta data에서 img로 처리하면 이미지로 인식함
    - url을 직접 전달해도 서비스상의 문제는 없고 편리하지만, 보안상의 이슈가 있을 수 있다.

### 리뷰 좋아요

- 리뷰의 좋아요 수는 매번 직접 계산하는건지, like_count 값이 있어서 그걸 +1/-1 해주는건지
    - 그냥 카운트 값을 필드에 넣어주고 좋아요/취소 할때마다 +-1 해주는게 낫다
- review_id+member_id를 복합 키로 설정하면 집계가 훨씬 빠를 것
    - 복합키로 설정 시 순서도 중요
- M : N 관계를 없애기 위한 테이블을 만들때는 관성적으로 새로운 id(auto_increment인)를 만들지 말고, 복합 키를 활용하여 성능 개선을 할 수 있는지 생각해보자
- 여러가지 방식의 조회를 자주 시행할 경우
    - 물리적인 index는 1개밖에 설정할수 없기 때문에
    - non-clustered index를 만들어서 조회 성능을 개선하는 것도 고려
        - 적어도 full-sacn보다는 빠르다
- 만약 like-history를 유지할 경우 review_id+member+id만으로 PK를 설정할 수 없음
    - 그럴 경우 고유성을 보장하려면 like를 누른 시간 등 까지도 고려해야 하는데 그렇게까지는 잘 하지 않는다

---

## 서버 로그

- 로그 레벨 warn 찍고, 실제로 중요한 정보(거래 정보)들은 남긴다
- info debug 수준은 개발단위에서만 주로 찍는다
    - 배포 단계에서는 절대 나오면 안된다.